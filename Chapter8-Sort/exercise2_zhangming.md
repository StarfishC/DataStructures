# 第八章-文件管理和外排序

## 8.1 教材习题

### 8.1.1 假设一个记录长 32B，一块长 1024B（因此每个块有 32 个记录），工作内存是 1MB（还有用于 I/O 缓冲区、程序变量等的其他存储空间）。使用置换选择和多路归并，其中归并算法只允许扫描两遍。预计能得到的文件最长为多少？试解释是怎样得到这个结果的

### 8.1.2 假设原有一个计算机系统，能处理一个大公司所有雇员记录的排序操作。由于公司合并，其雇员数目扩大为原来的 100 倍。计算机在可接受的时间内不能对原来的 100 倍的记录进行外排序。下面考虑用这几种独立的方案对计算机习题进行升级，它们是否能够满足新的外排序要求

**（1）CPU 的速度增长两倍**  
**（2）磁盘 I/O 时间缩短至原来的一半**  
**（3）内存存取时间缩短至原来的一半**  
**（4）内存发小增长两倍**

### 8.1.3 如果某个文件经内排序得到 80 个初始段并归并，试问

**（1）若使用多路归并执行 3 趟完成排序，那么应取的归并路数至少应为多少**  
**（2）如果操作系统要求一个程序同时可用的输入/输出文件的总数不超过 15 个，则按多路归并至少需要几趟可以完成排序？如果限定这个趟数，可取的最低路数是多少**

### 8.1.4 有 8 个顺串，每个顺串的第一个记录的关键码分别为 14、22、24、15、16、11、100、18，而第二个记录的关键码分别为 26、38、30、26、50、28、110、40。试画出对顺串开始 8 路归并时的败者树。从败者树输出一个全局赢者（并有相应的一个记录进入败者树）后需对败者树进行重构，试画出输出第一个全局赢者并进行重构后的败者树

### 8.1.5 算法 9.3 是一种败者树的实现方法。此外，还可以用另一种方法来初始化败者树：先构造一颗赢者树，然后把这颗赢者树映射成它所对应的败者树。这一种方法只需修改败者树的两个成员 Initialize()和 Play()。其中，Play()用于在 p 处的比较，赢者索引放在 B[p]中，若 B[p]是右孩子，则持续向上比赛；Initialize 先按选手索引顺序调用 Play()，生成赢者树之后，再映射成败者树。请实现该方法

### 8.1.6 设输入文件包含下列记录（仅列出其关键码值）：14、22、7、24、15、16、11、100、10、9、20、12、90、17、13、18、26、38、30、25、50、28、110、21、40、...，采用外部节点数为 8 的败者树方法对该文件生成初始顺串。试画出最初产生的败者树和最终输出的所有初始顺串

## 8.2 上机题

### 8.2.1 在磁盘中，图片一般作为数据一行一行的存储。16 色图片可以用 4 为表示一个像素。如果允许每个像素 8 位，则不需要解压缩像素的处理（由于 1 像素对应 1 字节，在大多数机器中字节是最低的寻址单位）。如果把两个像素压缩到一个字节中，就能节省空间，但是必须对像素进行压缩。对比每个像素 8 位和压缩为每个像素 4 位的情况，哪种情况从磁盘中读取并访问图像中每个像素所花的时间更多？对这两种情况进行编程，并比较需要的时间

### 8.2.2 根据本章描述的置换选择方法和多路归并算法实现一个外部排序。针对大记录文件和小记录文件两种情况测试你的程序，考虑记录为多大时，应该首先采用关键码排序，然后再根据排序结果重排原数据文件
